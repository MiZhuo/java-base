#### Synchronized和ReentrantLock的不同点
|  `Synchronized`   | `ReentrantLock`  |
|  ----  | ----  |
| Java关键字  | Jdk提供的一个类 |
| 自动加锁与释放锁  | 手动加锁与释放锁 |
| JVM层面锁 | API层面锁 |
| 非公平锁 | 公平锁或非公平锁 |
| 锁的是对象,锁信息保存在对象头中 | int类型的state标识来标识锁的状态 |
| 底层有锁升级过程 | 没有锁升级过程 |

#### 公平锁和非公平锁
- 公平锁
会先检查AQS队列中是否有线程在排队,如果有线程在排队则当前线程也进行排队。
- 非公平锁
  不去检查是否有线程排队,直接竞争锁。

不管是公平锁和非公平锁,一旦没有竞争到锁,都会进行排队。当锁被释放时,都是唤醒排在最前面的线程。所以非公平锁只是体现在加锁阶段,而没有体现在线程被唤醒阶段。

#### Synchronized 锁升级过程
**`偏向锁->轻量级锁->重量级锁`**
- 偏向锁
> 在锁对象的对象头中记录当前获取到该锁的线程ID,该线程下次再来获取这把锁可以直接获取到,也就是锁的可重入。
- 轻量级锁(自旋锁)
> 当一个线程获取到锁后,有第二个线程来竞争锁,偏向锁就会升级为轻量级锁,底层通过自旋来实现,不会阻塞线程。而自旋就是就线程通过CAS操作去获取预期的一个标记,如果没有获取到,则继续循环获取,如果获取到了,则说明获取到了锁。在自旋的过程中,线程一直在运行中,相对而言用的资源很少，所以比较轻量。
- 重量级锁(互斥锁)
> 如果自旋次数过多仍未获取到锁,轻量级锁会升级为重量级锁,重量级锁会阻塞线程。而阻塞和唤醒线程操作是需要操作系统去进行的,比较消耗时间和资源,所以比较重量级。

在JDK1.6之前,自旋的此时默认是10次,由 **-XX:PreBlockSpin** 控制。在JDK1.6之后加入了自适应自旋锁,次数由JVM控制。